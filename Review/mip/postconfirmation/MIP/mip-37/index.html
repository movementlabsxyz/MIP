<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MIP-37: FFS: Postconfirmation - MIP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../../favicon.png">
        <link rel="stylesheet" href="../../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../../css/general.css">
        <link rel="stylesheet" href="../../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../../highlight.css">
        <link rel="stylesheet" href="../../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MIP</h1>

                    <div class="right-buttons">
                        <a href="../../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/movementlabsxyz/MIP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="mip-37-ffs-postconfirmation"><a class="header" href="#mip-37-ffs-postconfirmation">MIP-37: FFS: Postconfirmation</a></h1>
<ul>
<li><strong>Description</strong>: Confirmations of superBlocks on L1. A sub-protocol of Fast Finality Settlement.</li>
<li><strong>Authors</strong>: Andreas Penzkofer</li>
<li><strong>Desiderata</strong>: <a href="https://github.com/movementlabsxyz/MIP/tree/mip/postconfirmation/MD/md-37">MD-37</a>, <a href="https://github.com/movementlabsxyz/MIP/pull/4">MD-4</a>, <a href="https://github.com/movementlabsxyz/MIP/pull/5">MD-5</a>, <a href="https://github.com/movementlabsxyz/MIP/pull/117">MD-117</a></li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Fast-Finality-Settlement (FFS) is proposed in <a href="https://github.com/movementlabsxyz/MIP/pull/34">MIP-34</a>, with two confirmation mechanisms: one on the base chain level (L1) and one on the rollup/sidechain level (L2). This MIP details the mechanism on Level 1 (L1), which is called <em><strong>Postconfirmation</strong></em>.</p>
<p>The L2 produces <strong>L2Blocks</strong>. At certain intervals validators commit a sequence of L2Blocks in a <em><strong>superBlock</strong></em>, to L1. The L1 contract will verify if &gt;2/3 of the validators have attested to a given superBlock height. The action for this validation is called Postconfirmation and it is initiated by the <em><strong>acceptor</strong></em>. The acceptor is a specific validator selected for some interval and it is added to the protocol to provide separation of concerns (attestations vs. Postconfirmation) and provide more predictable costs and rewards.</p>
<p>This provides an L1-protected guarantee that a superBlock (i.e. a sequence of L2Blocks) is accepted and correctly executed. This anchoring mechanism increases the security of the L2 as it protects the L2-state against long range attacks, see <a href="https://github.com/movementlabsxyz/MIP/tree/l-monninger/long-range-attacks/MD/md-5">MD-5</a>.</p>
<p>A introduction to Postconfirmation can also be found in <a href="https://blog.movementlabs.xyz/article/security-and-fast-finality-settlement">this blog post</a> and a more detailed description of a (partial) implementation of the mechanism is available at <a href="https://blog.movementlabs.xyz/article/Postconfirmations-L2s-rollups-blockchain-movement">this blog post</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>We require from the FFS protocol that it is secure and efficient, yet simple in its <em>initial</em> design. In order for the protocol to fulfill the requirement for simplicity, validators only communicate to the L1-contract and not with each other. This is a key design decision to reduce the complexity of the protocol, but can be improved in the future.</p>
<p>We also request that rewards and costs are made more predictable for validators. For this, we propose a special role – the acceptor – to perform the action of updating the L1 contract to accept a given state by super majority. This action is called Postconfirmation.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p><em>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174.</em></p>
<p>Figure 1 shows the leader-independent (deterministic) block generation process, which is also discussed in <a href="https://github.com/movementlabsxyz/MIP/pull/34">MIP-34: Fast Finality Settlement</a>.</p>
<p><img src="Postconfirmation.png" alt="Version A Diagram" />
<em>Figure 1: Leader-independent (deterministic) block generation process.</em></p>
<p>Since this document introduces a large number of new terms, we provide a specification by defining the terms and their interactions.</p>
<h4 id="domains---one-staking-contract-to-rule-them-all"><a class="header" href="#domains---one-staking-contract-to-rule-them-all">Domains - one staking contract to rule them all</a></h4>
<p>The L1 staking contract is intended to handle multiple chains. We differentiate between the chains by their unique identifier <code>domain</code> (of type <code>address</code>).</p>
<h4 id="l2blocks"><a class="header" href="#l2blocks">L2Blocks</a></h4>
<p>L2Blocks are deterministically derived from the sequencer-batches, which are called protoBlocks. Validators calculate the next deterministic transition (imposed through the sequence of transactions <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">x</span><span class="mord mathnormal">s</span></span></span></span>) <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0636em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0526em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">s</span><span class="mspace mtight"><span class="mtight"> </span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128 -16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85 -40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5 -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67  151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> are L2Blocks.</p>
<h4 id="superblock"><a class="header" href="#superblock">SuperBlock</a></h4>
<p>The Postconfirmation protocol is unlikely to attest to each individual L2Block. L2Blocks may be produced at higher frequency than L1Blocks or the cost of Postconfirmation is high, thus leading to low frequency commitments. Therefore, after a defined number of L2blocks, validators calculate the next (deterministic) superBlock and commit to it in the L1 contract. The L1 contract will verify (triggered by the acceptor) if &gt;2/3 of the validators have attested at a given superBlock height to a superBlock. Each incremental hight increase may be considered a round.</p>
<h4 id="validator"><a class="header" href="#validator">Validator</a></h4>
<p>A validator is a participant in the Postconfirmation protocol. They provide commitments to superBlocks by submitting transactions on the L1. For a given commitment height, a validator has <code>commitmentWindow</code> time to submit their commitment.</p>
<h4 id="commitment"><a class="header" href="#commitment">Commitment</a></h4>
<p>Validators commit the hash of the superBlock on the L1-contract. It commits the validator to a certain superBlock at a given height, with no option for changing their opinion. (This is intentional - validators should not be able to revert).</p>
<pre><code class="language-solidity">struct Commitment {
  uint256 height;
  bytes32 value;
  bytes32 id;
}
</code></pre>
<h4 id="epochs"><a class="header" href="#epochs">Epochs</a></h4>
<p>We require epochs in order to provide</p>
<ul>
<li><strong>secure on- and off-boarding process</strong> of validators. A validator MUST live in a well-defined state for a sufficient amount of time. The available states are <code>staked</code>, <code>unstaking</code>, and <code>not-staking</code> (in code only the former two may be required). This longevity of a given state both provides stability to the protocol, as well as is a security measure to prevent validators from harming the protocol towards the end of an epoch without implications. Specifically,
<ul>
<li>if a validator calls the <code>stake</code> function, the tokens get locked and voting SHOULD begin at the start of the next epoch.</li>
<li>if a validator calls the <code>unstake</code> function, voting SHOULD end at the end of the current epoch. The tokens SHOULD get unlocked no earlier than the end of the next epoch.</li>
</ul>
</li>
<li><strong>reward and penalty application</strong>. The borders between periods are also used to manage rewards and penalties. This also renders inefficiencies as calculation of voting weights could be expensive or attackable and thus it should be performed infrequent.</li>
</ul>
<p>The <code>epochDuration</code> MUST be set when initializing a chain. It MAY be changeable later on through a governance mechanism. The <code>epochDuration</code> should be set to a value that is large enough to allow for the <code>staking</code> and <code>unstaking</code> process to be completed. Moreover, it should be long enough for human operators to react.</p>
<blockquote>
<p>:bulb: The initial recommendation for <code>epochDuration</code> is 1 day, but it could be lower, as long as it is substantially larger than the finality time of the L1. E.g. in Ethereum the <code>epochDuration</code> could be 1 hour, however this would increase gas costs due to frequent epoch transitions.</p>
</blockquote>
<p>There are three relevant epoch types</p>
<h5 id="1-presentepoch"><a class="header" href="#1-presentepoch">1. <code>presentEpoch</code></a></h5>
<p><code>presentEpoch</code> is the epoch that is currently active on L1.</p>
<pre><code class="language-solidity">uint256 presentEpoch = getEpochFromL1BlockTime();
</code></pre>
<p>where</p>
<pre><code class="language-solidity">function getEpochFromL1BlockTime(address domain) public view returns (uint256) {
    return (block.timestamp - L1GenesisTime ) / epochDuration;
}
</code></pre>
<p>and <code>L1GenesisTime</code> is the time when the L1 contract was deployed.</p>
<h5 id="2-assignedepoch"><a class="header" href="#2-assignedepoch">2. <code>assignedEpoch</code></a></h5>
<p>If a commitment height is new, the current <code>presentEpoch</code> value is assigned to the commitment height.</p>
<pre><code class="language-solidity">/// map each commitment height to an epoch
mapping(uint256 commitmentHeight =&gt; uint256 epoch) public commitmentHeightAssignedEpoch;

// assume an instance of Commitment
Commitment memory commitment;

if (commitmentHeightAssignedEpoch[commitment.height] == 0) {
  commitmentHeightAssignedEpoch[commitment.height] = getEpochFromL1BlockTime();
}
</code></pre>
<p>Any validator can commit the hash of a superBlock. The rollover function should update to the correct epoch for a given commitment height (and the heights above).</p>
<blockquote>
<p>:warning: This may result in an attack vector. An adversary could commit to far in the future commitment heights. While this has no implications on the security, it may increase costs within the contract operation for the acceptor.</p>
</blockquote>
<p>As an initial measure, the height of the commitment should not be able to be set too far into the future. Hence there SHOULD be a <code>leadingBlockTolerance</code>, that limits how far into the future a block can be added.</p>
<pre><code class="language-solidity">if (lastPostconfirmedBlockHeight + leadingBlockTolerance &lt; blockCommitment.height) {
    revert ValidatorAlreadyCommitted();
    }
</code></pre>
<p>The validators have to check if the current commitment height (off-L1) is within the above window. Otherwise the commitment of the (honest) validator will not be added to the L1 contract.</p>
<h5 id="3-acceptingepoch"><a class="header" href="#3-acceptingepoch">3. <code>acceptingEpoch</code></a></h5>
<p>Votes are counted in the current <code>acceptingEpoch</code>. If there are enough votes for a commitment <code>id</code> the commitment height receives a Postconfirmation status (for the corresponding commitment value).</p>
<p>The current <code>acceptingEpoch</code> SHOULD be queried by</p>
<pre><code class="language-solidity">function getAcceptingEpoch() public view returns (uint256) {
    return acceptingEpoch;
}
</code></pre>
<h4 id="staking-and-unstaking"><a class="header" href="#staking-and-unstaking">Staking and Unstaking</a></h4>
<p>Validators can stake and unstake their tokens. The staking and unstaking process is managed by the staking contract. Validators can stake their tokens for a certain epoch. The staking process is initiated by the validator. The validator can also unstake their tokens, such that the stake is released at the end of the next epoch.</p>
<p>The reason for the delay in the unstaking process is to prevent validators from harming the protocol towards the end of an epoch without implications, and to remain accountable for at least one epoch. See also Section <a href="#epochs">Epochs</a>.</p>
<pre><code class="language-mermaid">gantt
    title Unstaking Timeline
    dateFormat  DD HH:mm
    axisFormat  %d %H:%M

    section Epochs
    Current epoch: active, currentEpoch, 01 00:00, 02 00:00
    Unstake epoch: unstakeEpoch, 02 00:00, 03 00:00
    Next epoch: releaseOfFundsEpoch, 03 00:01, 04 00:00

    section Actions
    Request for unstaking: milestone, 01 16:00, 1min
    Release of Funds: milestone, 03 00:00, 0min
</code></pre>
<p>We require functions <code>addStake</code>, <code>removeStake</code>, <code>addUnstake</code>, <code>removeUnstake</code> to manage the staking and unstaking process.</p>
<p>We require the following mappings</p>
<pre><code class="language-solidity">// Type aliases for better readability
type Domain is address;
type Epoch is uint256;
type Custodian is address;
type Attester is address;

// Mappings
mapping(Domain =&gt; mapping(Epoch =&gt; mapping(Custodian =&gt; mapping(Attester =&gt; uint256)))) public epochStakesByDomain;
mapping(Domain =&gt; mapping(Epoch =&gt; mapping(Custodian =&gt; uint256))) public epochTotalStakeByDomain;
mapping(Domain =&gt; mapping(Epoch =&gt; mapping(Custodian =&gt; mapping(Attester =&gt; uint256)))) public epochUnstakesByDomain;

</code></pre>
<p>For example, the addition functions are</p>
<pre><code class="language-solidity">function _addStake(
    address domain,
    uint256 epoch,
    address custodian,
    address attester,
    uint256 amount
) internal {
    epochStakesByDomain[domain][epoch][custodian][attester] += amount;
    epochTotalStakeByDomain[domain][epoch][custodian] += amount;
}
</code></pre>
<p>and</p>
<pre><code class="language-solidity">function _addUnstake(
    address domain,
    uint256 epoch,
    address custodian,
    address attester,
    uint256 amount
) internal {
    epochUnstakesByDomain[domain][epoch][custodian][attester] += amount;
}
</code></pre>
<h4 id="rollover"><a class="header" href="#rollover">Rollover</a></h4>
<p>The protocol increases the <code>acceptingEpoch</code> incrementally by one, i.e. the protocol progresses from one accepting epoch to the next. Whenever, such an incrementation happens, the stakes of the validators get adjusted to account for <code>staking</code> and <code>unstaking</code> events. This transition is called <em>Rollover</em>. On the default path the <code>rolloverEpoch</code> function is called by the <a href="#acceptor">acceptor</a>.</p>
<p>A rollover can occur in two types of paths:</p>
<ol>
<li>If the <code>assignedEpoch</code> of the next superBlock height falls into the next epoch, the protocol progresses to the next epoch.</li>
</ol>
<pre><code class="language-solidity">uint256 nextSuperBlockHeight = thisPostconfirmationBlockHeight + 1;
uint256 nextSuperBlockEpoch = superBlockHeightAssignedEpoch[nextSuperBlockHeight];
while (getAcceptingEpoch() &lt; NextSuperBlockEpoch) {
  rollOverEpoch();  // this also increments the acceptingEpoch
}
</code></pre>
<ol start="2">
<li>If the votes in the current <code>acceptingEpoch</code> are not sufficient to postconfirm a superBlock, and the <code>acceptingEpoch</code> is less than the <code>currentEpoch</code>, the protocol progresses to the next epoch.</li>
</ol>
<pre><code class="language-solidity">if (!superMajorityReached(thisSuperBlockHeight) &amp;&amp; getAcceptingEpoch() &lt; presentEpoch) {
    rollOverEpoch();  // this also increments the acceptingEpoch
}
</code></pre>
<blockquote>
<p>:warning: Close to the epoch border there should be some buffer. Otherwise the protocol rolls over too early.</p>
</blockquote>
<p>This step protects against liveness issues through inactive validators by taking advantage of the L1 clock. For more on this consult <a href="https://github.com/movementlabsxyz/MIP/pull/117">MD-117</a>. The current <code>acceptingEpoch</code> has not been live and should be skipped.</p>
<h4 id="acceptor"><a class="header" href="#acceptor">Acceptor</a></h4>
<p>An acceptor provides the postconfirmation functionality and rolls over the epoch. In order to allow for sufficient time for honest validators to provide their commitments, the postconfirmation for a given commitment SHOULD be delayed.</p>
<p>Every interval <code>acceptorTerm</code> one of the validators takes on the role to perform the Postconfirmation functionality. This acceptor is responsible for updating the contract state once a super-majority is reached for a commitment height. The acceptor is rewarded for this service, see the <a href="#rewards">Rewards section</a>. We note that this does not equate to a leader in a traditional consensus protocol, as the acceptor does not propose new states. Its role can also be taken over by a <a href="#volunteer-acceptor">volunteer-acceptor</a>.</p>
<blockquote>
<p>:bulb: We separate the acceptor from the validators to achieve separation of concerns and simplify the reward mechanism for the validators. This addresses <a href="https://github.com/movementlabsxyz/MIP/tree/l-monninger/gas-offset/MD/md-4">MD-4:D1</a>.</p>
</blockquote>
<p>The acceptor MUST be selected via L1-randomness and weighted by the stake. The randomness MAY be provided through L1Block hashes, which can be considered sufficiently random, initially. Alternative higher-quality randomness from L1 SHOULD be considered.</p>
<pre><code class="language-solidity">function getCurrentAcceptor() public view returns (address) {
  uint256 currentL1BlockHeight = block.number;
  // deduct finalizationBlockDepth because we should only consider finalized L1 blocks
  uint256 relevantL1BlockHeight = currentL1BlockHeight - (currentL1BlockHeight / acceptorTerm ) -  finalizationBlockDepth; 
  bytes32 blockHash = blockhash(relevantL1BlockHeight);
  return = getAcceptorFromL1Randomness(blockHash);

function getAcceptorFromL1Randomness(bytes32 blockHash) internal view returns (address) {
  // Implement logic to get the acceptor from the L1 randomness
  // and that considers the stake.
}
</code></pre>
<pre><code class="language-mermaid">gantt
    title Acceptor : Postconfirmation Timeline
    dateFormat  DD HH:mm
    axisFormat  %d %H:%M

    section Phases
    commitmentInterval :active, commitWindow, 01 00:00, 01 12:00
    acceptorWindow     :active, acceptorWindow, 01 12:00, 01 18:00

    section Events
    Validator 1 commits :milestone, v1, 01 02:00, 1min
    Validator 2 commits :milestone, v2, 01 04:00, 1min
    Validator 3 commits :milestone, v3, 01 06:00, 1min
    Acceptor too early ❌ :milestone, earlyA, 01 11:00, 1min
    Acceptor postconfirms ✅ :milestone, goodA, 01 13:00, 1min
</code></pre>
<h4 id="volunteer-acceptor"><a class="header" href="#volunteer-acceptor">Volunteer-acceptor</a></h4>
<p>The acceptor is supposed to update the contract state once enough votes are collected for the lowest unconfirmed commitment height. However, if the acceptor does not update the contract state for <code>acceptorWindow</code> the protocol allows for a volunteer-acceptor to provide the service.</p>
<p>The first volunteer-acceptor to provide the service of the acceptor after elapse of the liveness window will be accepted and receives the reward for the service, see <a href="#rewards">Rewards</a>. This is a liveness measure.</p>
<pre><code class="language-mermaid">gantt
    title Volunteer-acceptor : Postconfirmation Timeline
    dateFormat  DD HH:mm
    axisFormat  %d %H:%M

    section Phases
    commitmentWindow      :active, commitWindow, 01 00:00, 01 12:00
    acceptorWindow          :active, acceptorWindow, 01 12:00, 01 18:00
    . :active, volunteerWindow, 01 18:00, 01 20:00

    section Events
    Validator 1 commits     :milestone, v1, 01 01:00, 1min
    Validator 2 commits     :milestone, v2, 01 03:00, 1min
    Validator 3 commits     :milestone, v3, 01 06:00, 1min
    Acceptor-volunteer too early ❌    :milestone, volunteerActs, 01 13:00, 1min
    Acceptor did nothing    :milestone, aMissed, 01 18:00, 1min
    Acceptor-volunteer postconfirms ✅    :milestone, volunteerActs, 01 20:00, 1min
</code></pre>
<h4 id="rewards"><a class="header" href="#rewards">Rewards</a></h4>
<p><strong>Validators</strong> are rewarded for their service. The reward is calculated proportional to the validator stake and activity. The reward is issued in the next epoch.</p>
<p>The <strong>acceptor</strong> is rewarded for the service. The reward is calculated proportional to the activity. The reward is issued in the next epoch.</p>
<p>The <strong>volunteer-acceptor</strong> is rewarded for their service (the acceptor must have missed the liveness window <code>acceptorWindow</code>).</p>
<pre><code class="language-solidity">function rewardAcceptor(address acceptor) internal {
    uint256 reward = calculateAcceptorReward(acceptor);
    // Check if the acceptor has missed the liveness window
    if (!getCurrentAcceptor() == acceptor) {
        require(hasAcceptorMissedLivenessWindow(), "Volunteer-acceptor can only be rewarded if the acceptor missed the liveness window");
    }
    // add the reward to the reward queue, which gets processed at the end of the next epoch
    addReward(acceptor, reward);
}

function hasAcceptorMissedLivenessWindow() internal view returns (bool) {
    uint256 lastActivity = getAcceptorLastActivity();
    uint256 currentTime = block.timestamp;
    return currentTime &gt; lastActivity + acceptorWindow;
}

function getAcceptorLastActivity() internal view returns (uint256) {
    // This function should return the last recorded activity timestamp of the acceptor
    // Placeholder implementation, replace with actual storage retrieval
    return acceptorLastActivity;
}
</code></pre>
<h4 id="optional-slashing"><a class="header" href="#optional-slashing">(Optional) Slashing</a></h4>
<p>With Postconfirmations alone nodes do not need to get slashed if they voted for an invalid commitment. Since only their first vote for a given height gets accepted by the contract, they cannot equivocate. More abstractly the L1 provides consensus on the votes. Slashing MAY be considered to prevent flooding the L1 contract with invalid commitments, however, this is also expensive for the adversary and at most causes additional cost to the acceptor.</p>
<blockquote>
<p>:bulb: Nodes MAY get slashed if it has been proven that the validator voted more than once for a given block height on L2. This is a security measure to protect against long-range attacks. However, this is part of the scope of <a href="https://github.com/movementlabsxyz/MIP/pull/65">MIP-65: Fastconfirmations</a> and not Postconfirmations.</p>
</blockquote>
<h2 id="reference-implementation"><a class="header" href="#reference-implementation">Reference Implementation</a></h2>
<p>A reference implementation for MCR is provided <a href="https://github.com/movementlabsxyz/ffs/blob/4ffcccb950611964d5929cdb300638ecaebfe3c4/protocol/mcr/dlu/eth/contracts/src/settlement/MCR.sol">here</a>.</p>
<p>A reference implementation for PCP is provided <a href="https://github.com/movementlabsxyz/ffs/blob/4ffcccb950611964d5929cdb300638ecaebfe3c4/protocol/pcp/dlu/eth/contracts/src/settlement/PCP.sol">here</a>.</p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<h2 id="changelog"><a class="header" href="#changelog">Changelog</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../../Review/mip/FFS/MIP/mip-34/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../../../Review/mip/gas-fees-incremental-additions/MIP/mip-47/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../../Review/mip/FFS/MIP/mip-34/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../../../Review/mip/gas-fees-incremental-additions/MIP/mip-47/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../../../elasticlunr.min.js"></script>
        <script src="../../../../../mark.min.js"></script>
        <script src="../../../../../searcher.js"></script>

        <script src="../../../../../clipboard.min.js"></script>
        <script src="../../../../../highlight.js"></script>
        <script src="../../../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
